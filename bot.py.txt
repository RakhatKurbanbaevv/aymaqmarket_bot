@dp.callback_query(lambda c: c.data == 'checkout')
async def checkout(callback: types.CallbackQuery):
    await callback.message.answer('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è:')
    await dp.storage.set_data(callback.from_user.id, {'step': 'name'})

@dp.message()
async def handle_checkout(message: types.Message):
    data = await dp.storage.get_data(message.from_user.id)
    if not data or 'step' not in data:
        return

    conn = sqlite3.connect('shop.db')
    cursor = conn.cursor()

    if data['step'] == 'name':
        await dp.storage.set_data(message.from_user.id, {'step': 'phone', 'name': message.text})
        await message.answer('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:')

    elif data['step'] == 'phone':
        await dp.storage.set_data(message.from_user.id, {'step': 'address', 'name': data['name'], 'phone': message.text})
        await message.answer('–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏:')

    elif data['step'] == 'address':
        name = data['name']
        phone = data['phone']
        address = message.text

        cursor.execute('''
            SELECT products.name, products.price, cart.quantity
            FROM cart JOIN products ON cart.product_id = products.id
            WHERE cart.user_id=?
        ''', (message.from_user.id,))
        items = cursor.fetchall()

        items_text = ''
        total = 0
        for pname, price, qty in items:
            subtotal = price * qty
            items_text += f'{pname} x{qty} ‚Äî {subtotal} —Å—É–º\n'
            total += subtotal

        cursor.execute('INSERT INTO orders (user_id, name, phone, address, items, total) VALUES (?, ?, ?, ?, ?, ?)',
                       (message.from_user.id, name, phone, address, items_text, total))
        cursor.execute('DELETE FROM cart WHERE user_id=?', (message.from_user.id,))
        conn.commit()
        conn.close()

        await dp.storage.set_data(message.from_user.id, {})
        await message.answer(f'–°–ø–∞—Å–∏–±–æ –∑–∞ –∑–∞–∫–∞–∑!\n\n{name}\n–¢–µ–ª: {phone}\n–ê–¥—Ä–µ—Å: {address}\n\n{items_text}–ò—Ç–æ–≥–æ: {total} —Å—É–º')

        admin_id = await get_admin_id()
        await bot.send_message(admin_id, f'–ù–æ–≤—ã–π –∑–∞–∫–∞–∑!\n\n{name}\n–¢–µ–ª: {phone}\n–ê–¥—Ä–µ—Å: {address}\n\n{items_text}–ò—Ç–æ–≥–æ: {total} —Å—É–º')

@dp.message(lambda message: message.text == 'üì¶ –ú–æ–∏ –∑–∞–∫–∞–∑—ã')
async def my_orders(message: types.Message):
    conn = sqlite3.connect('shop.db')
    cursor = conn.cursor()
    cursor.execute('SELECT id, items, total FROM orders WHERE user_id=?', (message.from_user.id,))
    orders = cursor.fetchall()
    conn.close()

    if not orders:
        await message.answer('–£ –≤–∞—Å –Ω–µ—Ç –∑–∞–∫–∞–∑–æ–≤.')
        return

    text = ''
    for oid, items, total in orders:
        text += f'–ó–∞–∫–∞–∑ ‚Ññ{oid}\n{items}–ò—Ç–æ–≥–æ: {total} —Å—É–º\n\n'
    await message.answer(text)

@dp.message(Command('add_product'))
async def add_product(message: types.Message):
    admin_id = await get_admin_id()
    if message.from_user.id != admin_id:
        await message.answer('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞.')
        return
    await message.answer('–û—Ç–ø—Ä–∞–≤—å –¥–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n–ù–∞–∑–≤–∞–Ω–∏–µ;–û–ø–∏—Å–∞–Ω–∏–µ;–¶–µ–Ω–∞;–°—Å—ã–ª–∫–∞_–Ω–∞_—Ñ–æ—Ç–æ')

@dp.message(lambda message: ';' in message.text)
async def save_product(message: types.Message):
    admin_id = await get_admin_id()
    if message.from_user.id != admin_id:
        return
    try:
        name, desc, price, photo = message.text.split(';')
        conn = sqlite3.connect('shop.db')
        cursor = conn.cursor()
        cursor.execute('INSERT INTO products (name, description, price, photo) VALUES (?, ?, ?, ?)',
                       (name.strip(), desc.strip(), int(price.strip()), photo.strip()))
        conn.commit()
        conn.close()
        await message.answer('–¢–æ–≤–∞—Ä –¥–æ–±–∞–≤–ª–µ–Ω!')
    except Exception as e:
        await message.answer(f'–û—à–∏–±–∫–∞: {e}')

if name == 'main':
    init_db()
    asyncio.run(dp.start_polling(bot))